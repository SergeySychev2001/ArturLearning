Event Loop (цикл событий) — это ключевая концепция в JavaScript, которая позволяет выполнять асинхронный код, несмотря на то что JavaScript является однопоточным языком. Основная задача Event Loop — управлять выполнением кода, обработки событий и выполнение операций, ожидающих завершения.

### Основные компоненты Event Loop

1. **Call Stack (стек вызовов)**: Это структура данных, где хранятся функции, которые вызываются во время выполнения 
программы. Когда функция вызывается, она добавляется (помещается) в стек. Как только функция завершает выполнение, она удаляется из стека.

2. **Web APIs (веб API)**: Это набор браузерных API, например, для работы с таймерами (`setTimeout`), обработкой событий и 
AJAX-запросами (например, `fetch`). Когда асинхронная операция выполняется (например, запрашивается сетевой ресурс), она передается 
на уровень Web API.

3. **Task Queue (очередь заданий)**: Это очередь, куда помещаются функции обратного вызова (callback) после завершения асинхронных 
операций. Например, когда таймер заканчивается или AJAX-запрос завершается, функции из этих операций помещаются в очередь.

4. **Microtask Queue (очередь микрозаданий)**: Это специальная очередь для задач, которая находится в приоритете выше очереди заданий.
 Например, промисы (`Promise`) добавляют свои обработчики в эту очередь.

Как работает Event Loop

1. **Запуск кода**: JavaScript начинает выполнение кода, который находится в стек вызовов. Все синхронные операции выполняются по порядку.

2. **Асинхронные операции**: Когда код включает асинхронные операции (например, `setTimeout`, API-запросы), выполнение этих операций передается на Web API, а сама функция не блокирует выполнение кода.

3. **Завершение асинхронных операций**: Как только асинхронная операция завершилась, соответствующая callback-функция помещается в Task Queue или Microtask Queue в зависимости от типа.

4. **Очистка стека вызовов**: Как только стек вызовов очищается (все синхронные задачи были выполнены), Event Loop проверяет наличие задач в Microtask Queue и выполняет их по порядку, пока очередь не опустеет.

5. **Обработка Task Queue**: После обработки всех микрозаданий, Event Loop переключается на Task Queue и начинает выполнять задачи из нее по мере их поступления.

### Визуальное представление

1. Код выполняется из Stack (стека).
2. Асинхронные операции переходят на Web APIs.
3. Завершившиеся операции помещаются в Microtask Queue или Task Queue.
4. Event Loop контролирует и управляет переходами между этими структурами.

### Пример:

javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise");
});

console.log("End");


#### Ожидаемый вывод:


Start
End
Promise
Timeout


Здесь:
- "Start" и "End" выполнены синхронно.
- Вызов `Promise` помещает `then` в Microtask Queue.
- `setTimeout` помещает его в Task Queue.
- После завершения стека Event Loop сначала выполняет все микрозадания из Microtask Queue, а затем переходит к Task Queue.